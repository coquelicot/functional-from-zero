# vim: set ts=2 sw=2 sts=2 :

((\define

  define (\x x) \id
  define (\g \f \x g (f x)) \.
  define (\f (\x x x) (\x \u f (x x) u)) \Y

  define (\a \b \f f a b) \pair
  define (\p p (\a \b a)) \first
  define (\p p (\a \b b)) \second

  define (\f id) \0
  define (\n \f . f (n f)) \++
  define (++ 0) \1

  define (\n \m n ++ m) \+
  define (\n \m . n m) \*
  define (\n \m m n) \**

  define (\n first (n (\p pair (second p) (++ (second p))) (pair 0 0))) \--
  define (\n \m m -- n) \-

  define (\c \t \f c (\_ t) f .) \if
  define (\c if c (\_ 0) (\_ 1)) \!
  define (\a \b if a (\_ b) (\_ 0)) \&&
  define (\a \b if a (\_ 1) (\_ b)) \||

  define (\n \m - m n) \<
  define (\n \m - n m) \>
  define (\n \m ! (< n m)) \>=
  define (\n \m ! (> n m)) \<=
  define (\n \m || (< n m) (> n m)) \!=
  define (\n \m ! (!= n m)) \==

  define (
    Y \/ \n \m
      (if (< n m)
        (\_ 0)
        (\_ ++ (/ (- n m) m)))
  ) \/
  define (\n \m - n (* (/ n m) m)) \%

  define (++ 1) \2
  define (++ 2) \3
  define (++ 3) \4
  define (++ 4) \5
  define (++ 5) \6
  define (++ 6) \7
  define (++ 7) \8
  define (++ 8) \9

  define (pair 1 0) \[]
  define (\h \t pair 0 (pair h t)) \:
  define (. first second) \head
  define (. second second) \tail
  define first \emp?

  define (: 5 (: 1 (: 4 []))) \tmt
  define (: 5 (: 0 (: 2 (: 1 (: 6 []))))) \peter

  define (
    Y \foldl \f \acc \xs
      if (emp? xs)
        (\_ acc)
        (\_ foldl f (f acc (head xs)) (tail xs))
  ) \foldl
  define (
    Y \foldr \f \acc \xs
      if (emp? xs)
        (\_ acc)
        (\_ f (head xs) (foldr f acc (tail xs)))
  ) \foldr

  define (\f foldr (\x \acc : (f x) acc) []) \map
  define (\xs \ys foldr : ys xs) \+++
  define (foldl (\acc \x : x acc) []) \reverse

  define (
    (Y \bin8 \n \xs \c
      if n
        (\_ bin8 (-- n) (: (% c 2) xs) (/ c 2))
        (\_ xs)
    ) 8 []
  ) \bin

  define (
    (Y \chr8 \n \v \xs
      if n
        (\_ chr8 (-- n) (+ (* v 2) (head xs)) (tail xs))
        (\_ v)
    ) 8 0
  ) \chr

  define (* 6 8) \'0'
  define (++ '0') \'1'
  define (++ '1') \'2'
  define (++ '2') \'3'
  define (++ '3') \'4'
  define (++ '4') \'5'
  define (++ '5') \'6'
  define (++ '6') \'7'
  define (++ '7') \'8'
  define (++ '8') \'9'
  define (++ (* 8 8)) \'A'
  define (++ 'A') \'B'
  define (++ 'B') \'C'
  define (++ 'C') \'D'
  define (++ 'D') \'E'
  define (++ 'E') \'F'
  define (++ 'F') \'G'
  define (++ 'G') \'H'
  define (++ 'H') \'I'
  define (++ 'I') \'J'
  define (++ 'J') \'K'
  define (++ 'K') \'L'
  define (++ 'L') \'M'
  define (++ 'M') \'N'
  define (++ 'N') \'O'
  define (++ 'O') \'P'
  define (++ 'P') \'Q'
  define (++ 'Q') \'R'
  define (++ 'R') \'S'
  define (++ 'S') \'T'
  define (++ 'T') \'U'
  define (++ 'U') \'V'
  define (++ 'V') \'W'
  define (++ 'W') \'X'
  define (++ 'X') \'Y'
  define (++ 'Y') \'Z'
  define (+ 'A' (** 2 5)) \'a'
  define (++ 'a') \'b'
  define (++ 'b') \'c'
  define (++ 'c') \'d'
  define (++ 'd') \'e'
  define (++ 'e') \'f'
  define (++ 'f') \'g'
  define (++ 'g') \'h'
  define (++ 'h') \'i'
  define (++ 'i') \'j'
  define (++ 'j') \'k'
  define (++ 'k') \'l'
  define (++ 'l') \'m'
  define (++ 'm') \'n'
  define (++ 'n') \'o'
  define (++ 'o') \'p'
  define (++ 'p') \'q'
  define (++ 'q') \'r'
  define (++ 'r') \'s'
  define (++ 's') \'t'
  define (++ 't') \'u'
  define (++ 'u') \'v'
  define (++ 'v') \'w'
  define (++ 'w') \'x'
  define (++ 'x') \'y'
  define (++ 'y') \'z'

  define 0 \eos
  define (++ 9) \endl
  define (** 2 5) \space

  define (
    (Y \build \xs \x
      if x
        (\_ build (: x xs))
        (\_ reverse xs))
    []
  ) \string

# IO a = w -> (a, w)
  define (\w ++ w) \next_w
# IO a -> w -> (a, w)
  define (\io \w io w) \run_io
# IO a -> (a -> IO b) -> IO b
  define (
    \io \f \w
      define (run_io io w) \paw
      define (f (first paw)) \iob
      run_io iob (second paw)
  ) \>>=
# IO a -> IO b -> IO b
  define (\a \b >>= a (\_ b)) \>>
# a -> IO a  (a -> w -> (a, w))
  define pair \return
# IO ()
  define (\w pair (__builtin_p0 w) (next_w w)) \putb_0
# IO ()
  define (\w pair (__builtin_p1 w) (next_w w)) \putb_1
# IO bool
  define (\w pair (__builtin_g 0 1) (next_w w)) \getb
# IO ()
  define (\w pair . w) \noio

# (a -> IO b) -> [a] -> IO [b]
  define (
    \f \xs
      (Y \run_ios \xs \ys \w
        if (emp? xs)
          (\_ (pair (reverse ys) w))
          (\_
            define (run_io (head xs) w) \paw
            run_ios (tail xs) (: (first paw) ys) (second paw)))
      (map f xs)
      []
  ) \mapM

  define (. (mapM (\b if b (\_ putb_1) (\_ putb_0))) bin) \putc
  define (\xs >> (mapM putc xs) (putc endl)) \puts

  define (
    >>= getb \b0 >>= getb \b1 >>= getb \b2 >>= getb \b3
    >>= getb \b4 >>= getb \b5 >>= getb \b6 >>= getb \b7
    return (chr (: b0 (: b1 (: b2 (: b3 (: b4 (: b5 (: b6 (: b7 [])))))))))
  ) \getc

  run_io (

    >>= (
      puts (string
        'H' 'e' 'l' 'l' 'o' space 'W' 'o' 'r' 'l' 'd' endl
        'P' 'l' 'e' 'a' 's' 'e' space 'i' 'n' 'p' 'u' 't' space '0' space 'o' 'r' space '1'
      eos)
    ) \_ >>= (
      getc
    ) \sel >>= (
      if (!= sel '0')
        (\_ puts (map (+ '0') tmt))
        (\_ puts (map (+ '0') peter))
    ) \_ noio

  ) 0

) (\v \f f v))
