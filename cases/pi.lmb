((\def (
  # prelude
  def (\x x) \id
  def (\g \f \x (g (f x))) \.
  def (\f (\x x x) (\x \u f (x x) u)) \Y
  def (\x (\_ x)) \const
  def (\f \x \y f y x) \flip

  # pair
  def (\x \y \f f x y) \pair
  def (\p p (\x \y x)) \first
  def (\p p (\x \y y)) \second

  # abort (by stack overflow :P)
  def (Y \f \x (pair x (f x))) \abort

  # placeholder
  def abort \_

  # numbers
  def (\f id) \0
  def (\n \f . f (n f)) \inc
  def (\n first (n (\p pair (second p) (inc (second p))) (pair 0 0))) \dec
  def (inc 0) \1

  # true, false, if
  def 1 \True
  def 0 \False
  def (\cond \t \f cond (const t) f id) \if
  def (\b if b (const False) (const True)) \not
  def (\a \b if a (const (if b (const True) (const False))) (const False)) \&&
  def (\a \b if a (const True) (const (if b (const True) (const False)))) \||
  def (\a \b if a (const (not b)) (const b)) \^

  # list
  def (pair True _) \[]
  def (\x \y pair False (pair x y)) \:
  def (first) \null
  def (. first second) \head
  def (. second second) \tail
  def (
    def (Y \f \acc \l
           if (null l)
              (\_ acc)
              (\_ f (: (head l) acc) (tail l))) \f
    f []) \reverse
  def (Y \map \f \xs
         if (null xs)
            (\_ [])
            (\_ (: (f (head xs)) (map f (tail xs))))) \map
  def (Y \!! \xs \idx
         if (null xs)
            abort
            (\_ if idx
                (\_ !! (tail xs) (dec idx))
                (\_ head xs))) \!!

  # addition / subtraction / mutiplication
  def (\m m inc) \+
  def (\m \n n dec m) \-
  def . \*
  def (\m \n n m) \**

  # comparison
  def (\n \m if (- m n) (const True) (const False)) \<
  def (\n \m not (|| (< n m) (< m n))) \==
  def (flip <) \>
  def (\n \m not (< n m)) \>=
  def (flip >=) \<=
  def (\n \m || (< n m) (> n m)) \!=

  # division / modulo
  def (Y \/ \m \n if (< m n) (const 0) (\_ inc (/ (- m n) n))) \/
  def (\m \n (- m (* (/ m n) n))) \%

  # small numbers
  def (inc 1) \2
  def (inc 2) \3
  def (inc 3) \4
  def (inc 4) \5
  def (inc 5) \6
  def (inc 6) \7
  def (inc 7) \8
  def (inc 8) \9

  # chars
  def (* 2 5) \10
  def (* 2 8) \16
  def (* 2 16) \32
  def (+ 16 32) \48
  def (* 2 32) \64
  def (+ 32 64) \96
  def (* 5 (* 5 5)) \125
  def (- 125 2) \123
  def 10 \newline
  def 32 \space
  def 48 \'0' def (inc '0') \'1' def (inc '1') \'2' def (inc '2') \'3' def (inc '3') \'4'
  def (inc '4') \'5' def (inc '5') \'6' def (inc '6') \'7' def (inc '7') \'8' def (inc '8') \'9'
  def (inc 64) \'A' def (inc 'A') \'B' def (inc 'B') \'C' def (inc 'C') \'D' def (inc 'D') \'E'
  def (inc 'E') \'F' def (inc 'F') \'G' def (inc 'G') \'H' def (inc 'H') \'I' def (inc 'I') \'J'
  def (inc 'J') \'K' def (inc 'K') \'L' def (inc 'L') \'M' def (inc 'M') \'N' def (inc 'N') \'O'
  def (inc 'O') \'P' def (inc 'P') \'Q' def (inc 'Q') \'R' def (inc 'R') \'S' def (inc 'S') \'T'
  def (inc 'T') \'U' def (inc 'U') \'V' def (inc 'V') \'W' def (inc 'W') \'X' def (inc 'X') \'Y'
  def (inc 'Y') \'Z'
  def (* 4 (+ 5 6)) \','
  def (+ 2 ',') \'.'
  def (inc 96) \'a' def (inc 'a') \'b' def (inc 'b') \'c' def (inc 'c') \'d' def (inc 'd') \'e'
  def (inc 'e') \'f' def (inc 'f') \'g' def (inc 'g') \'h' def (inc 'h') \'i' def (inc 'i') \'j'
  def (inc 'j') \'k' def (inc 'k') \'l' def (inc 'l') \'m' def (inc 'm') \'n' def (inc 'n') \'o'
  def (inc 'o') \'p' def (inc 'p') \'q' def (inc 'q') \'r' def (inc 'r') \'s' def (inc 's') \'t'
  def (inc 't') \'u' def (inc 'u') \'v' def (inc 'v') \'w' def (inc 'w') \'x' def (inc 'x') \'y'
  def (inc 'y') \'z'
  def 125 \'}'
  def 123 \'{'

  def (
    def (Y \f \acc \c if c (\_ f (: c acc)) (\_ reverse acc)) \f
    f []
  ) \<<EOS
  def 0 \EOS

  # for debug, world 0 panic.
  def (Y \seq \f seq) \seq
  def (\c if c __builtin_p1 __builtin_p0) \putb
  def (\c
    def (Y \f \c \i if i (\_ seq (f (/ c 2) (dec i)) (putb (% c 2))) id) \f
    f c 8
  ) \putc
  def (
    Y \panic \xs (const panic) (map putc xs)
  ) \panic

  # Old things of world 0
  def pair \0::pair
  def first \0::first
  def second \0::second
  def True \0::True
  def False \0::False
  def if \0::if
  def not \0::not
  def && \0::&&
  def || \0::||
  def 0 \0::0
  def 1 \0::1
  def 2 \0::2
  def 3 \0::3
  def 4 \0::4
  def 5 \0::5
  def dec \0::dec
  def inc \0::inc
  def + \0::+
  def - \0::-
  def / \0::/
  def ^ \0::^
  def > \0::>
  def < \0::<
  def : \0:::
  def [] \0::[]
  def == \0::==

  # types!
  def 0 \Pair
  def 1 \Bool
  def 2 \Symbol
  def 3 \List
  def 4 \U32
  def 5 \IO
  def (
    : (<<EOS 'P' 'a' 'i' 'r' EOS) (
    : (<<EOS 'B' 'o' 'o' 'l' EOS) (
    : (<<EOS 'S' 'y' 'm' 'b' 'o' 'l' EOS) (
    : (<<EOS 'L' 'i' 's' 't' EOS) (
    : (<<EOS 'U' '3' '2' EOS) (
    : (<<EOS 'I' 'O' EOS) (
    []))))))) \_type_table
  def (\v v first) \typeof
  def (!! _type_table) \typename

  # type check messages
  def (<<EOS 'E' 'x' 'p' 'e' 'c' 't' space 't' 'y' 'p' 'e' space EOS) \"Expect_type_"
  def (<<EOS ',' space 'b' 'u' 't' space 'g' 'o' 't' space EOS) \",_but_got_"
  def (<<EOS '.' EOS) \"."

  # Error messages
  def (<<EOS 'h' 'e' 'a' 'd' EOS) \"head"
  def (<<EOS 't' 'a' 'i' 'l' EOS) \"tail"
  def (<<EOS space 'c' 'a' 'l' 'l' 'e' 'd' space 'o' 'n' space 'e' 'm' 'p' 't' 'y' space 'l' 'i' 's' 't' EOS) \"_called_on_empty_list"
  def (<<EOS space 'c' 'a' 'l' 'l' 'e' 'd' space 'o' 'n' space 'e' 'm' 'p' 't' 'y' space 'l' 'i' 's' 't' EOS) \"_called_on_empty_list"
  def (<<EOS 'S' 'y' 'n' 't' 'a' 'x' space 'e' 'r' 'r' 'o' 'r' space 'e' 'x' 'p' 'e' 'c' 't' space EOS) \"Syntax_error_expect_"
  def (<<EOS '{' EOS) \"{"
  def (<<EOS '}' EOS) \"}"

  # dynamic type check
  def (\t \func \arg
    def (typeof arg) \arg_t
    if (== arg_t t)
      (\_ func arg)
      (\_ panic "Expect_type_" (typename t) ",_but_got_" (typename arg_t) "." (abort _))
  ) \_check_arg_type

  def (_check_arg_type Bool) \Bool:
  def (_check_arg_type Pair) \Pair:
  def (_check_arg_type Symbol) \Symbol:
  def (_check_arg_type List) \List:
  def (_check_arg_type U32) \U32:
  def (_check_arg_type IO) \IO:

  # world 0 -> world 1 converter.
  def (\v v second) \_down
  # def (\x \f f x) \_fix_arg
  def def \_fixed_arg
  def (\t \v _fixed_arg (pair t v)) \_with_type
  def (\t1 \f _check_arg_type t1 \x f (_down x)) \_up1
  def (\t1 \t2 \f _check_arg_type t1 \x _check_arg_type t2 \y f (_down x) (_down y)) \_up2
  def (_with_type Bool) \[Bool]
  def (_with_type Pair) \[Pair]
  def (_with_type Symbol) \[Symbol]
  def (_with_type List) \[List]
  def (_with_type U32) \[U32]
  def (_with_type IO) \[IO]

  def (\f \rx f (_fixed_arg rx)) \infixify

  def (\x \c [Bool] (0::== (typeof x) c)) \f::instanceof
  def (infixify f::instanceof) \instanceof

  # Update world 0: pair
  def (\x \y [Pair] (pair x y)) \pair
  def (_up1 Pair first) \first
  def (_up1 Pair second) \second
  def (infixify pair) \,

  # TODO: numbers

  # Update world 0: bool
  def ([Bool] 0::True) \True
  def ([Bool] 0::False) \False
  def (_up1 Bool 0::if) \if
  def (\x [Bool] ((_up1 Bool 0::not) x)) \not
  def (\x \y [Bool] ((_up2 Bool Bool 0::||) x y)) \f::||
  def (infixify f::||) \||
  def (\x \y [Bool] ((_up2 Bool Bool 0::&&) x y)) \f::&&
  def (infixify f::&&) \&&

  # Symbol type.
  # TODO(Darkpi): Can reuse different type if needed.
  def ([Symbol] 0::0) \cmp::EQ
  def ([Symbol] 0::1) \cmp::GT
  def ([Symbol] 0::2) \cmp::LT
  def ([Symbol] 0::3) \{
  def ([Symbol] 0::4) \}

  def (Symbol: \x Symbol: \y [Bool] (0::== (_down x) (_down y))) \f::Symbol::==
  def (infixify f::Symbol::==) \Symbol::==

  def (Symbol: \x Symbol: \y not (x Symbol::== y)) \f::Symbol::!=
  def (infixify f::Symbol::!=) \Symbol::!=

  # Reconstructing world 1 list.
  # ListRaw: (0::pair (1::bool) (0::pair item ListRaw))
  # List: _with_type List ListRaw
  def ([List] (0::pair True _)) \[]
  def (\x List: \y [List] (0::pair False (0::pair x (_down y)))) \f:::
  def (infixify f:::) \:
  def (List: \xs 0::first (_down xs)) \null
  def (List: \xs
         if (null xs)
            (\_ panic "head" "_called_on_empty_list" (abort _))
            (\_ 0::first (0::second (_down xs)))) \head
  def (List: \xs
         if (null xs)
            (\_ panic "tail" "_called_on_empty_list" (abort _))
            (\_ _with_type List (0::second (0::second (_down xs))))) \tail
  def (
    def (Y \f \acc \l
           if (null l)
              (\_ acc)
              (\_ f ((head l) : acc) (tail l))) \f
    List: \xs f [] xs) \reverse
  def (Y \map \f List: \xs
         if (null xs)
            (const [])
            (\_ ((f (head xs)) : (map f (tail xs))))) \map
  def (Y \filter \f List: \xs
         if (null xs)
            (const [])
            (\_ def (head xs) \h
                def (tail xs) \t
                if (f h) (\_ h : (filter f t)) (\_ t))) \filter
  def (Y \zip List: \xs List: \ys
         if ((null xs) || (null ys))
            (const [])
            (\_ ((head xs) , (head ys)) : (zip (tail xs) (tail ys)))) \zip
  def (Y \foldl \f \acc List: \xs
         if (null xs)
            (\_ acc)
            (\_ foldl f (f acc (head xs)) (tail xs))) \foldl
  def (Y \foldr \f \acc List: \xs
         if (null xs)
            (\_ acc)
            (\_ f (head xs) (foldr f acc (tail xs)))) \foldr

  # f: [a] -> b, a with type and not Symbol.
  # blockify f { a a a a a a } -> b
  def (\f
    def (Y \iter \acc \x
      if (x instanceof Symbol)
         (\_ if (x Symbol::== })
                (\_ f (reverse acc))
                (\_ panic "Syntax_error_expect_" "}" abort))
         (\_ iter (x : acc))) \iter
    Symbol: \x if (x Symbol::== {)
                  (\_ iter [])
                  (\_ panic "Syntax_error_expect_" "{" abort)) \blockify

  def (blockify id {) \List{

  # u32
  def 0::5 \_bitlenlog
  def (
    def (Y \incstep \l \x
      0::if l
        (\_ def (0::first x) \x0
            def (0::second x) \x1
            def (0::dec l) \nl
            def (incstep nl x1) \s1
            0::if (0::first s1)
                  (\_ def (incstep nl x0) \s0
                      0::pair (0::first s0)
                              (0::pair (0::second s0) (0::second s1)))
                  (\_ 0::pair 0::0
                              (0::pair x0 (0::second s1))))
        (\_ (0::pair x (0::not x)))) \incstep
    U32: \x [U32] (0::second (incstep _bitlenlog (_down x)))
  ) \inc

  def (
    def (Y \addstep \l \c \x \y
      0::if l
        (\_ def (0::first x) \x0
            def (0::second x) \x1
            def (0::first y) \y0
            def (0::second y) \y1
            def (0::dec l) \nl
            def (addstep nl c x1 y1) \s1
            def (addstep nl (0::first s1) x0 y0) \s0
            (0::pair (0::first s0)
                     (0::pair (0::second s0) (0::second s1))))
        (\_ (0::pair (0::if (0::> (0::+ c (0::+ x y)) 0::1)
                         (const 0::1)
                         (const 0::0))
                     (0::^ c (0::^ x y))))) \addstep
    U32: \x U32: \y
      [U32] (0::second (addstep _bitlenlog 0::0 (_down x) (_down y)))
  ) \f::+
  def (infixify f::+) \+

  def (
    def (Y \~step \l \x
      0::if l
        (\_ def (0::first x) \x0
            def (0::second x) \x1
            def (0::dec l) \nl
            (0::pair (~step nl x0) (~step nl x1)))
        (\_ 0::not x)) \~step
    U32: \x [U32] (~step _bitlenlog (_down x))
  ) \~

  def (
    def (Y \cmpstep \l \x \y
      0::if l
        (\_ def (0::first x) \x0
            def (0::second x) \x1
            def (0::first y) \y0
            def (0::second y) \y1
            def (0::dec l) \nl
            def (cmpstep nl x0 y0) \s0
            if (s0 Symbol::!= cmp::EQ)
               (const s0)
               \_ cmpstep nl x1 y1)
        (\_ 0::if (0::< x y)
                  (const cmp::LT)
                  (\_ 0::if (0::< y x)
                            (const cmp::GT)
                            (const cmp::EQ)))) \cmpstep
    U32: \x U32: \y
      (cmpstep _bitlenlog (_down x) (_down y))
  ) \f::cmp
  def (infixify f::cmp) \cmp

  def (Y \_0step \l
    0::if l
       (\_ def (_0step (0::dec l)) \v
           0::pair v v)
       (const 0::0)) \_0step
  def ([U32] (_0step _bitlenlog)) \0

  def (inc 0) \1 def (inc 1) \2 def (inc 2) \3 def (inc 3) \4 def (inc 4) \5
  def (inc 5) \6 def (inc 6) \7 def (inc 7) \8 def (inc 8) \9 def (inc 9) \10
  def (inc 10) \11 def (inc 11) \12 def (inc 12) \13 def (inc 13) \14 def (inc 14) \15
  def (inc 15) \16 def (inc 16) \17 def (inc 17) \18 def (inc 18) \19 def (inc 19) \20
  def (inc 20) \21 def (inc 21) \22 def (inc 22) \23 def (inc 23) \24 def (inc 24) \25
  def (inc 25) \26 def (inc 26) \27 def (inc 27) \28 def (inc 28) \29 def (inc 29) \30
  def (inc 30) \31 def (inc 31) \32


  def (U32: \x inc (~ x)) \neg
  def (U32: \x U32: \y (x + (neg y))) \f::-
  def (infixify f::-) \-
  def (U32: \x x - 1) \dec

  def (U32: \x U32: \y (x cmp y) Symbol::== cmp::LT) \f::U32::<
  def (infixify f::U32::<) \U32::<
  def (U32: \x U32: \y not (x U32::< y)) \f::U32::>=
  def (infixify f::U32::>=) \U32::>=
  def (U32: \x U32: \y (x cmp y) Symbol::== cmp::EQ) \f::U32::==
  def (infixify f::U32::==) \U32::==
  def (U32: \x U32: \y not (x U32::== y)) \f::U32::!=
  def (infixify f::U32::!=) \U32::!=

  def (0 U32::!=) \U32::to_bool

  # splitAt
  def (Y \splitAt U32: \idx List: \xs
    if (idx U32::== 0)
       (\_ ([] , xs))
       (\_ (def (head xs) \h
            def (tail xs) \t
            def (splitAt (dec idx) t) \res
            ((h : (first res)) , (second res))))) \splitAt
  def (Y \len List: \xs
    if (null xs)
       (const 0)
       (\_ inc (len (tail xs)))) \len

  def (Y \p2 U32: \x
    if (x U32::== 0)
       (const 1)
       (\_ def (p2 (dec x)) \v
           v + v)) \p2

  # a...b, or [] if a >= b
  def (Y \range U32: \a U32: \b
    if (a U32::>= b)
       (const [])
       (\_ a : (range (inc a) b))) \range

  # TODO(Darkpi): This is sloooooooooow.
  def (blockify (
    \bs (def (len bs) \l
         def (zip (reverse (range 0 l)) bs) \ps
         foldl f::+ 0 (
           map (\p if ((second p) U32::!= 0) (\_ p2 (first p)) (const 0))
               ps)))) \0b

  # debug main
  def (
    def (Y \printstep \l \x
      0::if l
        (\_ seq (printstep (0::dec l) (0::first x))
                (printstep (0::dec l) (0::second x)))
        (\_ putc (0::if x (const '1') (const '0')))) \printstep
    \x seq (putc '0') (putc 'b') (printstep _bitlenlog (_down x)) (putc newline)
  ) \puts_bin
  def (
    Y \puts_list \l
      if (null l)
         (\_ _)
         (\_ seq (puts_bin (head l)) (puts_list (tail l)))
  ) \puts_list

  def (map (\x x + x) (List{ 5 0 2 1 6 })) \t2
  seq
  # (puts_list t2)
  # (if (f::U32::== 0 0) (\_ puts_list t2) (\_ abort _))
  (puts_bin (0b { 1 1 0 0 0 1 0 0 0 0 1 0 1 0 0 0 }))
  # (puts_bin (~ 2))
)) \x \y y x)
