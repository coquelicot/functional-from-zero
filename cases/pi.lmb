((\def (
  # prelude
  def (\x x) \id
  def (\g \f \x (g (f x))) \.
  def (\f (\x x x) (\x \u f (x x) u)) \Y
  def (\x (\_ x)) \const
  def (\f \x \y f y x) \flip

  # pair
  def (\x \y \f f x y) \pair
  def (\p p (\x \y x)) \first
  def (\p p (\x \y y)) \second

  # abort (by stack overflow :P)
  def (Y \f \x (pair x (f x))) \abort

  # placeholder
  def abort \_

  # numbers
  def (\f id) \0
  def (\n \f . f (n f)) \inc
  def (\n first (n (\p pair (second p) (inc (second p))) (pair 0 0))) \dec
  def (inc 0) \1

  # true, false, if
  def 1 \True
  def 0 \False
  def (\cond \t \f cond (const t) f id) \if
  def (\b if b (const False) (const True)) \not
  def (\a \b if a (const (if b (const True) (const False))) (const False)) \&&
  def (\a \b if a (const True) (const (if b (const True) (const False)))) \||
  def (\a \b if a (const (not b)) (const b)) \^

  # list
  def (pair True _) \[]
  def (\x \y pair False (pair x y)) \:
  def (first) \null
  def (. first second) \head
  def (. second second) \tail
  def (
    def (Y \f \acc \l
           if (null l)
              (\_ acc)
              (\_ f (: (head l) acc) (tail l))) \f
    f []) \reverse
  def (Y \map \f \xs
         if (null xs)
            (\_ [])
            (\_ (: (f (head xs)) (map f (tail xs))))) \map
  def (Y \!! \xs \idx
         if (null xs)
            abort
            (\_ if idx
                (\_ !! (tail xs) (dec idx))
                (\_ head xs))) \!!

  # addition / subtraction / mutiplication
  def (\m m inc) \+
  def (\m \n n dec m) \-
  def . \*
  def (\m \n n m) \**

  # comparison
  def (\n \m if (- m n) (const True) (const False)) \<
  def (\n \m not (|| (< n m) (< m n))) \==
  def (flip <) \>
  def (\n \m not (< n m)) \>=
  def (flip >=) \<=
  def (\n \m || (< n m) (> n m)) \!=

  # division / modulo
  def (Y \/ \m \n if (< m n) (const 0) (\_ inc (/ (- m n) n))) \/
  def (\m \n (- m (* (/ m n) n))) \%

  # small numbers
  def (inc 1) \2
  def (inc 2) \3
  def (inc 3) \4
  def (inc 4) \5
  def (inc 5) \6
  def (inc 6) \7
  def (inc 7) \8
  def (inc 8) \9

  # chars
  def (* 2 5) \10
  def (* 2 8) \16
  def (* 2 16) \32
  def (+ 16 32) \48
  def (* 2 32) \64
  def (+ 32 64) \96
  def (* 5 (* 5 5)) \125
  def (- 125 2) \123
  def 10 \newline
  def 32 \space
  def 48 \'0' def (inc '0') \'1' def (inc '1') \'2' def (inc '2') \'3' def (inc '3') \'4'
  def (inc '4') \'5' def (inc '5') \'6' def (inc '6') \'7' def (inc '7') \'8' def (inc '8') \'9'
  def (inc 64) \'A' def (inc 'A') \'B' def (inc 'B') \'C' def (inc 'C') \'D' def (inc 'D') \'E'
  def (inc 'E') \'F' def (inc 'F') \'G' def (inc 'G') \'H' def (inc 'H') \'I' def (inc 'I') \'J'
  def (inc 'J') \'K' def (inc 'K') \'L' def (inc 'L') \'M' def (inc 'M') \'N' def (inc 'N') \'O'
  def (inc 'O') \'P' def (inc 'P') \'Q' def (inc 'Q') \'R' def (inc 'R') \'S' def (inc 'S') \'T'
  def (inc 'T') \'U' def (inc 'U') \'V' def (inc 'V') \'W' def (inc 'W') \'X' def (inc 'X') \'Y'
  def (inc 'Y') \'Z'
  def (* 4 (+ 5 6)) \','
  def (+ 2 ',') \'.'
  def (inc 96) \'a' def (inc 'a') \'b' def (inc 'b') \'c' def (inc 'c') \'d' def (inc 'd') \'e'
  def (inc 'e') \'f' def (inc 'f') \'g' def (inc 'g') \'h' def (inc 'h') \'i' def (inc 'i') \'j'
  def (inc 'j') \'k' def (inc 'k') \'l' def (inc 'l') \'m' def (inc 'm') \'n' def (inc 'n') \'o'
  def (inc 'o') \'p' def (inc 'p') \'q' def (inc 'q') \'r' def (inc 'r') \'s' def (inc 's') \'t'
  def (inc 't') \'u' def (inc 'u') \'v' def (inc 'v') \'w' def (inc 'w') \'x' def (inc 'x') \'y'
  def (inc 'y') \'z'
  def 125 \'}'
  def 123 \'{'

  def (
    def (Y \f \acc \c if c (\_ f (: c acc)) (\_ reverse acc)) \f
    f []
  ) \<<EOS
  def 0 \EOS

  # for debug, world 0 panic.
  def (Y \seq \f seq) \seq
  def (\c if c __builtin_p1 __builtin_p0) \putb
  def (\c
    def (Y \f \c \i if i (\_ seq (f (/ c 2) (dec i)) (putb (% c 2))) id) \f
    f c 8
  ) \putc
  def (
    Y \panic \xs (const panic) (map putc xs)
  ) \panic

  # Old things of world 0
  def pair \0::pair
  def first \0::first
  def second \0::second
  def True \0::True
  def False \0::False
  def if \0::if
  def not \0::not
  def && \0::&&
  def || \0::||
  def 0 \0::0
  def 1 \0::1
  def 2 \0::2
  def 3 \0::3
  def 4 \0::4
  def 5 \0::5
  def dec \0::dec
  def inc \0::inc
  def + \0::+
  def - \0::-
  def / \0::/
  def ^ \0::^
  def > \0::>
  def < \0::<
  def : \0:::
  def [] \0::[]
  def == \0::==
  def '0' \0::'0'

  # types!
  def 0 \Pair
  def 1 \Bool
  def 2 \Symbol
  def 3 \List
  def 4 \U32
  def 5 \IO
  def (
    : (<<EOS 'P' 'a' 'i' 'r' EOS) (
    : (<<EOS 'B' 'o' 'o' 'l' EOS) (
    : (<<EOS 'S' 'y' 'm' 'b' 'o' 'l' EOS) (
    : (<<EOS 'L' 'i' 's' 't' EOS) (
    : (<<EOS 'U' '3' '2' EOS) (
    : (<<EOS 'I' 'O' EOS) (
    []))))))) \_type_table
  def (\v v first) \typeof
  def (!! _type_table) \typename

  # type check messages
  def (<<EOS 'E' 'x' 'p' 'e' 'c' 't' space 't' 'y' 'p' 'e' space EOS) \"Expect_type_"
  def (<<EOS ',' space 'b' 'u' 't' space 'g' 'o' 't' space EOS) \",_but_got_"
  def (<<EOS '.' EOS) \"."

  # Error messages
  def (<<EOS 'h' 'e' 'a' 'd' EOS) \"head"
  def (<<EOS 't' 'a' 'i' 'l' EOS) \"tail"
  def (<<EOS space 'c' 'a' 'l' 'l' 'e' 'd' space 'o' 'n' space 'e' 'm' 'p' 't' 'y' space 'l' 'i' 's' 't' EOS) \"_called_on_empty_list"
  def (<<EOS space 'c' 'a' 'l' 'l' 'e' 'd' space 'o' 'n' space 'e' 'm' 'p' 't' 'y' space 'l' 'i' 's' 't' EOS) \"_called_on_empty_list"
  def (<<EOS 'S' 'y' 'n' 't' 'a' 'x' space 'e' 'r' 'r' 'o' 'r' space 'e' 'x' 'p' 'e' 'c' 't' space EOS) \"Syntax_error_expect_"
  def (<<EOS '{' EOS) \"{"
  def (<<EOS '}' EOS) \"}"
  def (<<EOS 'D' 'i' 'v' 'i' 's' 'i' 'o' 'n' space 'b' 'y' space '0' EOS) \"Division_by_0"

  # dynamic type check
  def (\t \func \arg
    def (typeof arg) \arg_t
    if (== arg_t t)
      (\_ func arg)
      (\_ panic "Expect_type_" (typename t) ",_but_got_" (typename arg_t) "." (abort _))
  ) \_check_arg_type

  def (_check_arg_type Bool) \Bool:
  def (_check_arg_type Pair) \Pair:
  def (_check_arg_type Symbol) \Symbol:
  def (_check_arg_type List) \List:
  def (_check_arg_type U32) \U32:
  def (_check_arg_type IO) \IO:

  # world 0 -> world 1 converter.
  def (\v v second) \_down
  # def (\x \f f x) \_fix_arg
  def def \_fixed_arg
  def (\t \v _fixed_arg (pair t v)) \_with_type
  def (\t1 \f _check_arg_type t1 \x f (_down x)) \_up1
  def (\t1 \t2 \f _check_arg_type t1 \x _check_arg_type t2 \y f (_down x) (_down y)) \_up2
  def (_with_type Bool) \[Bool]
  def (_with_type Pair) \[Pair]
  def (_with_type Symbol) \[Symbol]
  def (_with_type List) \[List]
  def (_with_type U32) \[U32]
  def (_with_type IO) \[IO]

  def (\f \rx f (_fixed_arg rx)) \infixify

  def (\x \c [Bool] (0::== (typeof x) c)) \f::instanceof
  def (infixify f::instanceof) \instanceof

  # Update world 0: pair
  def (\x \y [Pair] (pair x y)) \pair
  def (_up1 Pair first) \first
  def (_up1 Pair second) \second
  def (infixify pair) \,

  # TODO: numbers

  # Update world 0: bool
  def ([Bool] 0::True) \True
  def ([Bool] 0::False) \False
  def (_up1 Bool 0::if) \if
  def (\x [Bool] ((_up1 Bool 0::not) x)) \not
  def (\x \y [Bool] ((_up2 Bool Bool 0::||) x y)) \f::||
  def (infixify f::||) \||
  def (\x \y [Bool] ((_up2 Bool Bool 0::&&) x y)) \f::&&
  def (infixify f::&&) \&&

  # Symbol type.
  # TODO(Darkpi): Can reuse different type if needed.
  def ([Symbol] 0::0) \cmp::EQ
  def ([Symbol] 0::1) \cmp::GT
  def ([Symbol] 0::2) \cmp::LT
  def ([Symbol] 0::3) \{
  def ([Symbol] 0::4) \}

  def (Symbol: \x Symbol: \y [Bool] (0::== (_down x) (_down y))) \f::Symbol::==
  def (infixify f::Symbol::==) \Symbol::==

  def (Symbol: \x Symbol: \y not (x Symbol::== y)) \f::Symbol::!=
  def (infixify f::Symbol::!=) \Symbol::!=

  # Reconstructing world 1 list.
  # ListRaw: (0::pair (1::bool) (0::pair item ListRaw))
  # List: _with_type List ListRaw
  def ([List] (0::pair True _)) \[]
  def (\x List: \y [List] (0::pair False (0::pair x (_down y)))) \f:::
  def (infixify f:::) \:
  def (List: \xs 0::first (_down xs)) \null
  def (List: \xs
         if (null xs)
            (\_ panic "head" "_called_on_empty_list" (abort _))
            (\_ 0::first (0::second (_down xs)))) \head
  def (List: \xs
         if (null xs)
            (\_ panic "tail" "_called_on_empty_list" (abort _))
            (\_ _with_type List (0::second (0::second (_down xs))))) \tail
  def (
    def (Y \f \acc \l
           if (null l)
              (\_ acc)
              (\_ f ((head l) : acc) (tail l))) \f
    List: \xs f [] xs) \reverse
  def (Y \map \f List: \xs
         if (null xs)
            (const [])
            (\_ ((f (head xs)) : (map f (tail xs))))) \map
  def (Y \filter \f List: \xs
         if (null xs)
            (const [])
            (\_ def (head xs) \h
                def (tail xs) \t
                if (f h) (\_ h : (filter f t)) (\_ t))) \filter
  def (Y \zip List: \xs List: \ys
         if ((null xs) || (null ys))
            (const [])
            (\_ ((head xs) , (head ys)) : (zip (tail xs) (tail ys)))) \zip
  def (Y \foldl \f \acc List: \xs
         if (null xs)
            (\_ acc)
            (\_ foldl f (f acc (head xs)) (tail xs))) \foldl
  def (Y \foldr \f \acc List: \xs
         if (null xs)
            (\_ acc)
            (\_ f (head xs) (foldr f acc (tail xs)))) \foldr

  # f: [a] -> b, a with type and not Symbol.
  # blockify f { a a a a a a } -> b
  def (\f
    def (Y \iter \acc \x
      if (x instanceof Symbol)
         (\_ if (x Symbol::== })
                (\_ f (reverse acc))
                (\_ panic "Syntax_error_expect_" "}" (abort _)))
         (\_ iter (x : acc))) \iter
    Symbol: \x if (x Symbol::== {)
                  (\_ iter [])
                  (\_ panic "Syntax_error_expect_" "{" (abort _))) \blockify

  def (blockify id {) \List{

  # u32
  def 0::5 \_bitlenlog

  def (Y \_0step \l
    0::if l
       (\_ def (_0step (0::dec l)) \v
           0::pair v v)
       (const 0::0)) \_0step
  def ([U32] (_0step _bitlenlog)) \0

  def (
    def (Y \incstep \l \x
      0::if l
        (\_ def (0::first x) \x0
            def (0::second x) \x1
            def (0::dec l) \nl
            def (incstep nl x1) \s1
            0::if (0::first s1)
                  (\_ def (incstep nl x0) \s0
                      0::pair (0::first s0)
                              (0::pair (0::second s0) (0::second s1)))
                  (\_ 0::pair 0::0
                              (0::pair x0 (0::second s1))))
        (\_ (0::pair x (0::not x)))) \incstep
    U32: \x [U32] (0::second (incstep _bitlenlog (_down x)))) \inc

  def (Y \+step \l \c \x \y
    0::if l
      (\_ def (0::first x) \x0
          def (0::second x) \x1
          def (0::first y) \y0
          def (0::second y) \y1
          def (0::dec l) \nl
          def (+step nl c x1 y1) \s1
          def (+step nl (0::first s1) x0 y0) \s0
          (0::pair (0::first s0)
                   (0::pair (0::second s0) (0::second s1))))
      (\_ (0::pair (0::if (0::> (0::+ c (0::+ x y)) 0::1)
                       (const 0::1)
                       (const 0::0))
                   (0::^ c (0::^ x y))))) \_+step
  def (
    U32: \x U32: \y
      [U32] (0::second (_+step _bitlenlog 0::0 (_down x) (_down y)))) \f::+
  def (infixify f::+) \+

  def (
    def (Y \*step \l \x \y
      0::if l
        (\_ def (0::first x) \x0
            def (0::second x) \x1
            def (0::first y) \y0
            def (0::second y) \y1
            def (0::dec l) \nl
            def (*step nl x0 y0) \m00
            def (*step nl x1 y0) \m01
            def (*step nl x0 y1) \m10
            def (*step nl x1 y1) \m11
            def (_0step l) \0l
            def (_0step nl) \0nl
            def (0::pair m00 0l) \m00
            def (0::pair (0::pair 0nl (0::first m01)) (0::pair (0::second m01) 0nl)) \m01
            def (0::pair (0::pair 0nl (0::first m10)) (0::pair (0::second m10) 0nl)) \m10
            def (0::pair 0l m11) \m11
            0::second (_+step (0::inc l) 0::0
              (0::second (_+step (0::inc l) 0::0 m00 m01))
              (0::second (_+step (0::inc l) 0::0 m10 m11))))
        (\_ (0::pair 0::0 (0::&& x y)))) \*step
    U32: \x U32: \y
      [U32] (0::second (*step _bitlenlog (_down x) (_down y)))) \f::*
  def (infixify f::*) \*

  def (
    def (Y \~step \l \x
      0::if l
        (\_ def (0::first x) \x0
            def (0::second x) \x1
            def (0::dec l) \nl
            (0::pair (~step nl x0) (~step nl x1)))
        (\_ 0::not x)) \~step
    U32: \x [U32] (~step _bitlenlog (_down x))) \~

  def (
    def (Y \cmpstep \l \x \y
      0::if l
        (\_ def (0::first x) \x0
            def (0::second x) \x1
            def (0::first y) \y0
            def (0::second y) \y1
            def (0::dec l) \nl
            def (cmpstep nl x0 y0) \s0
            if (s0 Symbol::!= cmp::EQ)
               (const s0)
               \_ cmpstep nl x1 y1)
        (\_ 0::if (0::< x y)
                  (const cmp::LT)
                  (\_ 0::if (0::< y x)
                            (const cmp::GT)
                            (const cmp::EQ)))) \cmpstep
    U32: \x U32: \y
      (cmpstep _bitlenlog (_down x) (_down y))) \f::cmp
  def (infixify f::cmp) \cmp

  def (inc 0) \1 def (inc 1) \2 def (inc 2) \3 def (inc 3) \4 def (inc 4) \5
  def (inc 5) \6 def (inc 6) \7 def (inc 7) \8 def (inc 8) \9 def (inc 9) \10
  def (inc 10) \11 def (inc 11) \12 def (inc 12) \13 def (inc 13) \14 def (inc 14) \15
  def (inc 15) \16 def (inc 16) \17 def (inc 17) \18 def (inc 18) \19 def (inc 19) \20
  def (inc 20) \21 def (inc 21) \22 def (inc 22) \23 def (inc 23) \24 def (inc 24) \25
  def (inc 25) \26 def (inc 26) \27 def (inc 27) \28 def (inc 28) \29 def (inc 29) \30
  def (inc 30) \31 def (inc 31) \32

  def (U32: \x inc (~ x)) \neg
  def (U32: \x U32: \y (x + (neg y))) \f::-
  def (infixify f::-) \-
  def (U32: \x x - 1) \dec

  def (U32: \x U32: \y (x cmp y) Symbol::== cmp::LT) \f::U32::<
  def (infixify f::U32::<) \U32::<
  def (U32: \x U32: \y not (x U32::< y)) \f::U32::>=
  def (infixify f::U32::>=) \U32::>=
  def (U32: \x U32: \y (x cmp y) Symbol::== cmp::EQ) \f::U32::==
  def (infixify f::U32::==) \U32::==
  def (U32: \x U32: \y not (x U32::== y)) \f::U32::!=
  def (infixify f::U32::!=) \U32::!=
  def (U32: \x U32: \y (x cmp y) Symbol::== cmp::GT) \f::U32::>
  def (infixify f::U32::>) \U32::>
  def (U32: \x U32: \y not (x U32::> y)) \f::U32::<=
  def (infixify f::U32::<=) \U32::<=

  def (0 U32::!=) \U32::to_bool

  # splitAt
  def (Y \splitAt U32: \idx List: \xs
    if (idx U32::== 0)
       (\_ ([] , xs))
       (\_ (def (head xs) \h
            def (tail xs) \t
            def (splitAt (dec idx) t) \res
            ((h : (first res)) , (second res))))) \splitAt
  def (Y \length List: \xs
    if (null xs)
       (const 0)
       (\_ inc (length (tail xs)))) \length

  # a...b, or [] if a >= b
  def (Y \range U32: \a U32: \b
    if (a U32::>= b)
       (const [])
       (\_ a : (range (inc a) b))) \range

  def (Y \pow U32: \x U32: \y
    if (y U32::== 0)
       (const 1)
       (\_ x * (pow x (dec y)))) \pow

  def (\base \xs
    def (length xs) \l
    def (zip (reverse (range 0 l)) xs) \ps
    foldl f::+ 0 (
      map (\p (second p) * (pow base (first p))) ps)) \list_to_u32

  def (
    def (Y \step \l \x
      0::if l
        (\_ def (step (0::dec l) (0::first x)) \f1
            ((if ((first f1) U32::== 0)
                 (\_ def (step (0::dec l) (0::second x)) \f2
                     if ((first f2) U32::== 0)
                        (const 0)
                        (\_ (first f2) + (second f2)))
                 (const (first f1)))
             , ((second f1) + (second f1))))
        (\_ ((0::if x (const 1) (const 0)) , 1))) \step
    U32: \x (first (step _bitlenlog (_down x))) - 1
  ) \_first_1

  # Finally division...
  def (
    def (Y \step \l \x \y
      def (pow 2 l) \dig
      def (y * dig) \yy
      if (l U32::== 0)
         (\_ if (x U32::>= yy) (\_ (dig , (x - yy))) (\_ (0 , x)))
         (\_ if (x U32::>= yy)
                (\_ def (step (dec l) (x - yy) y) \s
                    ((dig + (first s)) , (second s)))
                (\_ step (dec l) x y))) \step
    U32: \x U32: \y
      if (y U32::== 0)
         (\_ panic "Division_by_0" (abort _))
         (\_ step (_first_1 y) x y)) \divmod
  def (infixify (U32: \x U32: \y first (divmod x y))) \/
  def (infixify (U32: \x U32: \y second (divmod x y))) \%

  # TODO(Darkpi): This is sloooooooooow. We at least should have a faster 0b ?
  def (blockify (list_to_u32 2)) \0b
  def (blockify (list_to_u32 10)) \0d

  # characters
  def 10 \newline
  def (32 + 16) \'0' def (inc '0') \'1' def (inc '1') \'2' def (inc '2') \'3' def (inc '3') \'4'
  def (inc '4') \'5' def (inc '5') \'6' def (inc '6') \'7' def (inc '7') \'8' def (inc '8') \'9'

  # IO
  # a -> IO a
  def (\x [IO] (const x)) \return
  def (IO: \io (_down io) _) \_runIO
  # IO a -> (a -> IO b) -> IO b
  def (IO: \io \f
    [IO] (\_ _runIO (f (_runIO io)))) \f::>>=
  def (infixify f::>>=) \>>=

  # Basic IO
  # IO Bool
  # TODO(Darkpi): Fix EOF.
  def ([IO] \_ __builtin_g False True _ _) \_getbit
  # Bool -> IO ()
  def (Bool: \b [IO] (\_ if b (\_ __builtin_p1 _) (\_ __builtin_p0 _))) \_putbit

  # U32 (char) -> IO ()
  # TODO(Darkpi): We may want a char type.
  def (
    def (Y \step \l \c
           if (l U32::== 0)
              (const return _)
              (\_ (step (dec l) (c / 2)) >>= (\_ _putbit (U32::to_bool (c % 2))))) \step
    U32: \c step 8 c) \putchar

  # U32 -> IO ()
  def (
    def (Y \step \x
      if (x U32::== 0)
         (\_ return _)
         (\_ def (divmod x 10) \r
             (step (first r)) >>= (\_ putchar ('0' + (second r))))) \step
    \x (if (x U32::== 0) (\_ putchar '0') (\_ step x))) \U32::write
  def U32::write \write

  def (\x (write x) >>= (\_ putchar newline)) \puts

  # IO U32 (char)
  def (
    def (Y \step \l
           if (l U32::== 0)
              (\_ return 0)
              (\_ (step (dec l)) >>= \x _getbit >>= \b return (x * 2 + (if b (const 1) (const 0))))) \step
    step 8) \getchar

  # IO U32
  # Read until not number.
  def (
    def (Y \step \x
      getchar >>= \c
      if ((c U32::>= '0') && (c U32::<= '9'))
         (\_ step (x * 10 + c - '0'))
         (\_ return x)) \step
    step 0
  ) \U32::read
  def U32::read \read

  # debug main
  def (Y \gcd \x \y
         if (x U32::== 0)
            (const y)
            (\_ gcd (y % x) x)) \gcd

  def (Y \main \_
    read >>= \x
    read >>= \y
    if ((x U32::== 0) && (y U32::== 0))
       (\_ return _)
       (\_ puts (gcd x y) >>= \_ main _)) \main

  def (__builtin_debug id) \_

  _runIO (main _)
)) \x \y y x)
