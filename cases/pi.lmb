(\def (
  # prelude
  def (\x x) \id
  def (\g \f \x (g (f x))) \.
  def (\f (\x x x) (\x \u f (x x) u)) \Y
  def (\x (\_ x)) \const
  def (\f \x \y f y x) \flip

  # pair
  def (\x \y \f f x y) \pair
  def (\p p (\x \y x)) \first
  def (\p p (\x \y y)) \second

  # abort (by stack overflow :P)
  def (Y \f \x (pair x (f x))) \abort

  # placeholder
  def abort \_

  # numbers
  def (\f id) \0
  def (\n \f . f (n f)) \inc
  def (\n first (n (\p pair (second p) (inc (second p))) (pair 0 0))) \dec
  def (inc 0) \1

  # true, false, if
  def 1 \True
  def 0 \False
  def (\cond \t \f cond (const t) f id) \if
  def (\b if b (const False) (const True)) \not
  def (\a \b if a (const (if b (const True) (const False))) (const False)) \&&
  def (\a \b if a (const True) (const (if b (const True) (const False)))) \||
  def (\a \b if a (const (not b)) (const b)) \^

  # list
  def (pair True _) \[]
  def (\x \y pair False (pair x y)) \:
  def (first) \null
  def (. first second) \head
  def (. second second) \tail
  def (
    def (Y \f \acc \l
           if (null l)
              (\_ acc)
              (\_ f (: (head l) acc) (tail l))) \f
    f []) \reverse
  def (Y \map \f \xs
         if (null xs)
            (\_ [])
            (\_ (: (f (head xs)) (map f (tail xs))))) \map
  def (Y \!! \xs \idx
         if (null xs)
            abort
            (\_ if idx
                (\_ !! (tail xs) (dec idx))
                (\_ head xs))) \!!

  # addition / subtraction / mutiplication
  def (\m m inc) \+
  def (\m \n n dec m) \-
  def . \*
  def (\m \n n m) \**

  # comparison
  def (\n \m if (- m n) (const True) (const False)) \<
  def (\n \m not (|| (< n m) (< m n))) \==
  def (flip <) \>
  def (\n \m not (< n m)) \>=
  def (flip >=) \<=
  def (\n \m || (< n m) (> n m)) \!=

  # division / modulo
  def (Y \/ \m \n if (< m n) (const 0) (\_ inc (/ (- m n) n))) \/
  def (\m \n (- m (* (/ m n) n))) \%

  # small numbers
  def (inc 1) \2
  def (inc 2) \3
  def (inc 3) \4
  def (inc 4) \5
  def (inc 5) \6
  def (* 2 4) \8

  # chars
  def (* 2 8) \16
  def (* 2 16) \32
  def (+ 16 32) \48
  def (* 2 32) \64
  def (+ 32 64) \96
  def 32 \space
  def 48 \'0' def (inc '0') \'1' def (inc '1') \'2' def (inc '2') \'3' def (inc '3') \'4'
  def (inc '4') \'5' def (inc '5') \'6' def (inc '6') \'7' def (inc '7') \'8' def (inc '8') \'9'
  def (inc 64) \'A' def (inc 'A') \'B' def (inc 'B') \'C' def (inc 'C') \'D' def (inc 'D') \'E'
  def (inc 'E') \'F' def (inc 'F') \'G' def (inc 'G') \'H' def (inc 'H') \'I' def (inc 'I') \'J'
  def (inc 'J') \'K' def (inc 'K') \'L' def (inc 'L') \'M' def (inc 'M') \'N' def (inc 'N') \'O'
  def (inc 'O') \'P' def (inc 'P') \'Q' def (inc 'Q') \'R' def (inc 'R') \'S' def (inc 'S') \'T'
  def (inc 'T') \'U' def (inc 'U') \'V' def (inc 'V') \'W' def (inc 'W') \'X' def (inc 'X') \'Y'
  def (inc 'Y') \'Z'
  def (* 4 (+ 5 6)) \','
  def (+ 2 ',') \'.'
  def (inc 96) \'a' def (inc 'a') \'b' def (inc 'b') \'c' def (inc 'c') \'d' def (inc 'd') \'e'
  def (inc 'e') \'f' def (inc 'f') \'g' def (inc 'g') \'h' def (inc 'h') \'i' def (inc 'i') \'j'
  def (inc 'j') \'k' def (inc 'k') \'l' def (inc 'l') \'m' def (inc 'm') \'n' def (inc 'n') \'o'
  def (inc 'o') \'p' def (inc 'p') \'q' def (inc 'q') \'r' def (inc 'r') \'s' def (inc 's') \'t'
  def (inc 't') \'u' def (inc 'u') \'v' def (inc 'v') \'w' def (inc 'w') \'x' def (inc 'x') \'y'
  def (inc 'y') \'z'

  def (
    def (Y \f \acc \c if c (\_ f (: c acc)) (\_ reverse acc)) \f
    f []
  ) \<<EOS
  def 0 \EOS

  # for debug, world 0 panic.
  def (Y \seq \f seq) \seq
  def (\c if c __builtin_p1 __builtin_p0) \putb
  def (\c
    def (Y \f \c \i if i (\_ seq (f (/ c 2) (dec i)) (putb (% c 2))) id) \f
    f c 8
  ) \putc
  def (
    Y \panic \xs (const panic) (map putc xs)
  ) \panic

  # Old things of world 0
  def pair \0::pair
  def first \0::first
  def second \0::second
  def True \0::True
  def False \0::False
  def if \0::if
  def not \0::not
  def && \0::&&
  def || \0::||
  def 0 \0::0
  def 1 \0::1
  def 2 \0::2
  def 5 \0::5
  def dec \0::dec
  def inc \0::inc
  def + \0::+
  def - \0::-
  def / \0::/
  def ^ \0::^
  def > \0::>
  def < \0::<
  def : \0:::
  def [] \0::[]
  def == \0::==

  # types!
  def 0 \Pair
  def 1 \Bool
  def 2 \List
  def 3 \U32
  def (
    : (<<EOS 'P' 'a' 'i' 'r' EOS) (
    : (<<EOS 'B' 'o' 'o' 'l' EOS) (
    : (<<EOS 'L' 'i' 's' 't' EOS) (
    : (<<EOS 'U' '3' '2' EOS) (
    []))))) \_type_table
  def first \typeof
  def (!! _type_table) \typename

  # type check messages
  def (<<EOS 'E' 'x' 'p' 'e' 'c' 't' space 't' 'y' 'p' 'e' space EOS) \"Expect_type_"
  def (<<EOS ',' space 'b' 'u' 't' space 'g' 'o' 't' space EOS) \",_but_got_"
  def (<<EOS '.' EOS) \"."

  # Error messages
  def (<<EOS 'h' 'e' 'a' 'd' EOS) \"head"
  def (<<EOS 't' 'a' 'i' 'l' EOS) \"tail"
  def (<<EOS space 'c' 'a' 'l' 'l' 'e' 'd' space 'o' 'n' space 'e' 'm' 'p' 't' 'y' space 'l' 'i' 's' 't' EOS) \"_called_on_empty_list"

  # dynamic type check
  def (\t \func \arg
    def (typeof arg) \arg_t
    if (== arg_t t)
      (\_ func arg)
      (\_ panic "Expect_type_" (typename t) ",_but_got_" (typename arg_t) "." (abort _))
  ) \_check_arg_type

  def (_check_arg_type Bool) \Bool:
  def (_check_arg_type Pair) \Pair:
  def (_check_arg_type List) \List:
  def (_check_arg_type U32) \U32:

  # world 0 -> world 1 converter.
  def second \_down
  def pair \_with_type
  def (\t \f \x _with_type t (f x)) \_up_return
  def (\t1 \f _check_arg_type t1 \x f (_down x)) \_up1
  def (\t1 \t2 \f _check_arg_type t1 \x _check_arg_type t2 \y f (_down x) (_down y)) \_up2
  def (_with_type Bool) \[Bool]
  def (_with_type Pair) \[Pair]
  def (_with_type List) \[List]
  def (_with_type U32) \[U32]

  # Update world 0: pair
  def (\x \y [Pair] (pair x y)) \pair
  def (_up1 Pair first) \first
  def (_up1 Pair second) \second

  # TODO: numbers

  # Update world 0: bool
  def ([Bool] 0::True) \True
  def ([Bool] 0::False) \False
  def (_up1 Bool if) \if
  def (_up_return Bool (_up1 Bool not)) \not
  def (_up_return Bool (_up2 Bool Bool ||)) \||
  def (_up_return Bool (_up2 Bool Bool &&)) \&&

  # Reconstructing world 1 list.
  # ListRaw: (0::pair (1::bool) (0::pair item ListRaw))
  # List: _with_type List ListRaw
  def ([List] (0::pair True _)) \[]
  def (\x List: \y [List] (0::pair False (0::pair x (_down y)))) \:
  def (List: \xs 0::first (_down xs)) \null
  def (List: \xs
         if (null xs)
            (\_ panic "head" "_called_on_empty_list" (abort _))
            (\_ 0::first (0::second (_down xs)))) \head
  def (List: \xs
         if (null xs)
            (\_ panic "tail" "_called_on_empty_list" (abort _))
            (\_ _with_type List (0::second (0::second (_down xs))))) \tail
  def (
    def (Y \f \acc \l
           if (null l)
              (\_ acc)
              (\_ f (: (head l) acc) (tail l))) \f
    List: \xs f [] xs) \reverse
  def (Y \map \f List: \xs
         if (null xs)
            (\_ [])
            (\_ (: (f (head xs)) (map f (tail xs))))) \map
  def (Y \filter \f List: \xs
         if (null xs)
            (\_ [])
            (\_ def (head xs) \h
                def (tail xs) \t
                if (f h) (: h (filter f t)) t)) \filter

  # u32
  def 0::5 \_bitlenlog
  def (
    def (Y \incstep \l \x
      0::if l
        (\_ def (0::first x) \x0
            def (0::second x) \x1
            def (0::dec l) \nl
            def (incstep nl x1) \s1
            0::if (0::first s1)
                  (\_ def (incstep nl x0) \s0
                      0::pair (0::first s0)
                              (0::pair (0::second s0) (0::second s1)))
                  (\_ 0::pair 0::0
                              (0::pair x0 (0::second s1))))
        (\_ (0::pair x (0::not x)))) \incstep
    U32: \x [U32] (0::second (incstep _bitlenlog (_down x)))
  ) \inc

  def (
    def (Y \addstep \l \c \x \y
      0::if l
        (\_ def (0::first x) \x0
            def (0::second x) \x1
            def (0::first y) \y0
            def (0::second y) \y1
            def (0::dec l) \nl
            def (addstep nl c x1 y1) \s1
            def (addstep nl (0::first s1) x0 y0) \s0
            (0::pair (0::first s0)
                     (0::pair (0::second s0) (0::second s1))))
        (\_ (0::pair (0::if (0::> (0::+ c (0::+ x y)) 0::1)
                         (const 0::1)
                         (const 0::0))
                     (0::^ c (0::^ x y))))) \addstep
    U32: \x U32: \y
      [U32] (0::second (addstep _bitlenlog 0::0 (_down x) (_down y)))
  ) \+

  def (
    def (Y \~step \l \x
      0::if l
        (\_ def (0::first x) \x0
            def (0::second x) \x1
            def (0::dec l) \nl
            (0::pair (~step nl x0) (~step nl x1)))
        (\_ 0::not x)) \~step
    U32 \x [U32] (~step _bitlenlog (_down x))
  ) \~

  # TODO(Darkpi): Symbol type.
  def 0::2 \LT
  def 0::1 \GT
  def 0::0 \EQ

  def (
    def (Y \cmpstep \l \x \y
      0::if l
        (\_ def (0::first x) \x0
            def (0::second x) \x1
            def (0::first y) \y0
            def (0::second y) \y1
            def (0::dec l) \nl
            def (cmpstep nl x0 y0) \s0
            0::if s0 (const s0)
                     (\_ cmpstep nl x1 y1))
        (\_ 0::if (0::< x y)
                  (const LT)
                  (\_ 0::if (0::< y x)
                            (const GT)
                            (const EQ)))) \cmpstep
    U32: \x U32: \y
      (cmpstep _bitlenlog (_down x) (_down y))
  ) \cmp

  def (
    def (Y \0step \l
      0::if l
         (\_ def (0step (dec l)) \v
             0::pair v v)
         (const 0::0)) \0step
    [U32] (0step _bitlenlog)
  ) \0

  def (inc 0) \1
  def (inc 1) \2

  def (U32: \x inc (~ x)) \neg
  def (U32: \x U32: \y (+ x (neg y))) \-

  def (U32: \x U32: \y [Bool] (0::== LT (cmp x y))) \<
  def (U32: \x U32: \y [Bool] (0::== EQ (cmp x y))) \==

  # debug main
  def (\n n __builtin_debug n) \dbg
  seq
  # (__builtin_debug True)
  # (__builtin_debug False)
  # (__builtin_debug (not False))
  # seq
  # (__builtin_debug (0::first (_down 0)))
  # (__builtin_debug (0::second (_down 0)))
  # (__builtin_debug (0::first (_down 1)))
  # (__builtin_debug (0::second (_down 1)))
  # (dbg (cmp 1 0))
  (if (< 1 0) (\_ dbg 0::1) (\_ dbg 0::2))
  # seq (dbg 0) (dbg 1) (dbg 2) (dbg 3) (dbg 4)
  #   (dbg (head tl))
  #   (dbg (head (reverse tl)))
)) \x \y y x
